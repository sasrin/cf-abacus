'use strict';

// Test a module using Istanbul and Mocha

// Implemented in ES5 for now
/* eslint no-var: 0 */

var _ = require('underscore');
var path = require('path');
var util = require('util');
var smap = require('source-map');
var csmap = require('convert-source-map');
var textcov = require('./textcov.js');
var istanbul = require('istanbul');
var Mocha = require('mocha');
var fs = require('fs');

/* eslint no-process-exit: 1 */
/* eslint no-eval: 1 */
/* jshint evil: true */

// Return true if a file belongs to the current module or a subdirectory of
// that module
var inThisModule = function(file) {
    var rel = path.relative(process.cwd(), file);
    return /^lib\/[^\/]*\.js$/.test(rel) || /^lib\/[^\/]*\/[^\/]*\.js$/.test(rel);
};

// Return true if a file is a test
var inTestDir = function(file) {
    var rel = path.relative(process.cwd(), file);
    return /^lib\/test\//.test(rel);
};

// Return true if a file belongs to a abacus module or a subdirectory
// of that module
var inAbacusModule = function(file) {
    return inThisModule(file) || /\/abacus-[^\/]*\/lib\/[^\/]*\.js$/.test(file) || /\/abacus-[^\/]*\/lib\/[^\/]*\/[^\/]*\.js$/.test(file);
};

// Return a transform function that transforms a file and records the original
// source and a source map in the given sets
var transformer = function(sources, maps) {
    // Set up an instrument function that will instrument the relevant code
    var instrumenter = new istanbul.Instrumenter({ coverageVariable: '__coverage', preserveComments: true });
    var noinstrument = process.env.NO_ISTANBUL;
    var instrument = function(code, file) {
        if(!noinstrument && inAbacusModule(file) && !inTestDir(file)) {
            process.stdout.write(util.format('Running Istanbul instrumentation on %s\n', path.relative(process.cwd(), file)));
            return instrumenter.instrumentSync(code, file);
        }
        return code;
    };

    // Return the configured transform function
    return function(code, file) {
        // Record the original source of a file generated by Babel
        var lib = file.split('/');
        var l = lib.lastIndexOf('lib');
        sources[file] = fs.readFileSync(lib.slice(0, l).concat(['src']).concat(lib.slice(l + 1)).join('/')).toString();

        // Record the corresponding source map
        maps[file] = new smap.SourceMapConsumer(csmap.fromSource(code).sourcemap);

        // Instrument with Istanbul
        return instrument(code, file);
    };
};

// Remap Istanbul statement, function and branch coverage maps to the original
// source code using the given set of source maps
var remap = function(coverage, maps) {
    _.map(_.values(coverage), function(cov) {
        var map = maps[cov.path];
        if(!map) return;

        var reloc = function(l) {
            var start = map.originalPositionFor(l.start);
            if(start.line !== null) l.start = start;
            var end = map.originalPositionFor(l.end);
            if(end.line !== null) l.end = end;
        };

        _.map(_.values(cov.statementMap), function(s) { reloc(s); });
        _.map(_.values(cov.fnMap), function(f) {
            reloc(f.loc);
            f.line = f.loc.start.line;
        });
        _.map(_.values(cov.branchMap), function(b) {
            _.map(b.locations, function(l) { reloc(l); });
            b.line = b.locations[0].start.line;
        });
    });
    return coverage;
};

// Return the directory containing the test target sources
var target = function() {
    try {
        fs.lstatSync('lib');
        return 'lib';
    }
    catch (e) {
        return 'src';
    }
};

// Run Mocha with Babel and Istanbul
var runCLI = function() {
    process.stdout.write('Testing...\n');
    var t0 = new Date();

    // Declare test to Mocha
    var mocha = new Mocha(process.env.MOCHA_COLORS ? { useColors: true, timeout: 20000 } : {});
    mocha.addFile(target() + '/test/test.js');

    // Install Chai expect and Sinon spy and stub as globals
    global.chai = require('chai');
    global.expect = global.chai.expect;
    global.sinon = require('sinon');
    global.spy = global.sinon.spy;
    global.stub = global.sinon.stub;

    // Install an Istanbul require transform hook that transpiles relevant
    // files to ES5 using Babel then instruments them for coverage
    var sources = [];
    var maps = [];
    istanbul.hook.hookRequire(inAbacusModule, transformer(sources, maps));

    // Run the test with Mocha
    mocha.run(function(failures) {
        var t1 = Date.now();

        // Print the test execution time
        var time = function() {
            process.stdout.write(util.format('\nRun time %dms\n', t1 - t0));
        };

        if(!global.__coverage) {
            time();
            process.exit(failures);
        }

        // Remap the generated source coverage maps using the collected source
        // maps
        remap(global.__coverage, maps);

        // Write the JSON and LCOV coverage reports
        var collector = new istanbul.Collector();
        collector.add(global.__coverage);
        var coverage = collector.getFinalCoverage();
        var reporter = new istanbul.Reporter(undefined, '.coverage');
        reporter.addAll(['lcovonly']);
        reporter.write(collector, false, function() {
            fs.writeFileSync('.coverage/coverage.json', JSON.stringify(coverage));

            // Print a detailed source coverage text report and the test
            // execution time
            textcov(coverage, sources);
            time();

            process.exit(failures);
        });
    });
};

// Export our public functions
module.exports.runCLI = runCLI;

